export const algorithmInfo = {
  'Bubble Sort': {
    description: 'Repeatedly compares adjacent elements and swaps them if they\'re in the wrong order.',
    whenToUse: 'Small datasets, educational purposes, nearly sorted data',
    pros: 'Simple to understand and implement, stable sort, in-place',
    cons: 'Very slow O(n²) performance, inefficient for large datasets',
    realWorld: 'Teaching sorting concepts, small embedded systems with limited memory',
  },
  'Cocktail Shaker Sort': {
    description: 'Bidirectional bubble sort that alternates between forward and backward passes.',
    whenToUse: 'When elements are mostly sorted but with outliers at both ends',
    pros: 'Slightly better than bubble sort, handles turtles better',
    cons: 'Still O(n²), minimal improvement over bubble sort',
    realWorld: 'Rarely used in practice, mostly of academic interest',
  },
  'Insertion Sort': {
    description: 'Builds sorted array one element at a time by inserting each into its correct position.',
    whenToUse: 'Small datasets, nearly sorted data, online sorting',
    pros: 'Efficient for small data, adaptive, stable, in-place, simple',
    cons: 'O(n²) for large datasets, requires shifting elements',
    realWorld: 'Sorting small arrays, final optimization in hybrid sorts like Timsort',
  },
  'Selection Sort': {
    description: 'Repeatedly finds the minimum element and places it at the beginning.',
    whenToUse: 'When write operations are expensive, memory is limited',
    pros: 'Minimizes number of swaps, simple, works with any data type',
    cons: 'O(n²) always, not adaptive, unstable',
    realWorld: 'Flash memory where writes are costly, simple embedded systems',
  },
  'Shell Sort': {
    description: 'Generalization of insertion sort using gap sequences to allow distant exchanges.',
    whenToUse: 'Medium-sized datasets, when O(n log n) is unavailable',
    pros: 'Better than O(n²) algorithms, in-place, relatively simple',
    cons: 'Complexity depends on gap sequence, unstable',
    realWorld: 'Embedded systems, kernel-level sorting, legacy systems',
  },
  'Heap Sort': {
    description: 'Uses binary heap data structure to efficiently find and extract maximum elements.',
    whenToUse: 'When O(n log n) worst-case is required, limited memory',
    pros: 'O(n log n) guaranteed, in-place, no quadratic worst case',
    cons: 'Not stable, slower than quicksort in practice, poor cache performance',
    realWorld: 'Priority queues, real-time systems, kernel sorting',
  },
  'Merge Sort': {
    description: 'Divide-and-conquer algorithm that splits array, sorts halves, then merges them.',
    whenToUse: 'Large datasets, when stability is required, linked lists',
    pros: 'O(n log n) guaranteed, stable, predictable performance, parallelizable',
    cons: 'O(n) extra space, slower for small arrays',
    realWorld: 'External sorting, database operations, parallel processing, Timsort base',
  },
  'Quick Sort': {
    description: 'Divide-and-conquer using pivot partitioning to recursively sort subarrays.',
    whenToUse: 'General-purpose sorting, large datasets, when average case matters',
    pros: 'Fast O(n log n) average, in-place, cache-efficient',
    cons: 'O(n²) worst case, unstable, recursive (stack space)',
    realWorld: 'Standard library sorts (C qsort), most general-purpose sorting',
  },
  'Counting Sort': {
    description: 'Non-comparison sort using counting array for integer keys within known range.',
    whenToUse: 'Small integer range, need linear time, have extra space',
    pros: 'O(n + k) time, stable, predictable performance',
    cons: 'Requires extra space O(k), only for integers, inefficient for large ranges',
    realWorld: 'Radix sort subroutine, small range data, histogram sorting',
  },
  'Bogo Sort (Fun)': {
    description: 'Randomly shuffles the array until it happens to be sorted. Purely for entertainment!',
    whenToUse: 'Never use this! Only for educational humor and demonstrations',
    pros: 'Incredibly simple to understand, guaranteed to eventually finish (probably)',
    cons: 'O(n × n!) average time - catastrophically slow, completely impractical',
    realWorld: 'Academic jokes, teaching what NOT to do, making other algorithms look good',
  },
  'Gnome Sort': {
    description: 'Simple algorithm that moves elements to proper position like a gnome sorting pots.',
    whenToUse: 'Very small datasets, when simplicity is key, educational purposes',
    pros: 'Extremely simple code, stable, in-place, similar to insertion sort',
    cons: 'O(n²) performance, slower than insertion sort in practice',
    realWorld: 'Rarely used, mostly academic interest, embedded systems',
  },
  'Comb Sort': {
    description: 'Improvement over bubble sort using diminishing gap sequence to eliminate turtles.',
    whenToUse: 'When bubble sort would be used but better performance is needed',
    pros: 'Better than bubble sort, simple to implement, in-place',
    cons: 'Still O(n²) worst case, unstable, irregular performance',
    realWorld: 'Alternative to bubble sort in constrained environments',
  },
};
